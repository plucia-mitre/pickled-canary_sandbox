// Copyright (C) 2024 The MITRE Corporation All Rights Reserved

package org.mitre.pickledcanary.patterngenerator;

import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Stack;
import java.util.TreeMap;

import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.json.JSONArray;
import org.json.JSONObject;
import org.mitre.pickledcanary.PickledCanary;
import org.mitre.pickledcanary.patterngenerator.generated.pc_grammar;
import org.mitre.pickledcanary.patterngenerator.generated.pc_grammarBaseVisitor;
import org.mitre.pickledcanary.patterngenerator.generated.pc_lexer;
import org.mitre.pickledcanary.patterngenerator.output.steps.AnyByteSequence;
import org.mitre.pickledcanary.patterngenerator.output.steps.Byte;
import org.mitre.pickledcanary.patterngenerator.output.steps.Context;
import org.mitre.pickledcanary.patterngenerator.output.steps.Jmp;
import org.mitre.pickledcanary.patterngenerator.output.steps.Label;
import org.mitre.pickledcanary.patterngenerator.output.steps.LookupStep;
import org.mitre.pickledcanary.patterngenerator.output.steps.MaskedByte;
import org.mitre.pickledcanary.patterngenerator.output.steps.Match;
import org.mitre.pickledcanary.patterngenerator.output.steps.NegativeLookahead;
import org.mitre.pickledcanary.patterngenerator.output.steps.OrMultiState;
import org.mitre.pickledcanary.patterngenerator.output.steps.Split;
import org.mitre.pickledcanary.patterngenerator.output.steps.SplitMulti;
import org.mitre.pickledcanary.patterngenerator.output.steps.Step;
import org.mitre.pickledcanary.patterngenerator.output.steps.Step.StepType;
import org.mitre.pickledcanary.patterngenerator.output.utils.AllLookupTables;
import org.mitre.pickledcanary.patterngenerator.output.utils.LookupStepBuilder;
import org.mitre.pickledcanary.search.Pattern;

import ghidra.app.plugin.assembler.AssemblySelector;
import ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult;
import ghidra.app.plugin.assembler.sleigh.sem.AssemblyPatternBlock;
import ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution;
import ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolutionResults;
import ghidra.app.plugin.assembler.sleigh.sem.DefaultAssemblyResolvedPatterns;
import ghidra.app.plugin.processors.sleigh.SleighInstructionPrototype;
import ghidra.app.plugin.processors.sleigh.SleighLanguage;
import ghidra.asm.wild.WildSleighAssembler;
import ghidra.asm.wild.WildSleighAssemblerBuilder;
import ghidra.asm.wild.sem.DefaultWildAssemblyResolvedPatterns;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.DisassemblerContextAdapter;
import ghidra.program.model.lang.InsufficientBytesException;
import ghidra.program.model.lang.Register;
import ghidra.program.model.lang.RegisterValue;
import ghidra.program.model.lang.UnknownInstructionException;
import ghidra.program.model.listing.Program;
import ghidra.program.model.listing.ProgramContext;
import ghidra.program.model.mem.ByteMemBufferImpl;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.util.task.TaskMonitor;

/**
 * This class creates the generated pattern. There are two major steps to do this: 1. Process the
 * user pattern. This involves taking the token generated by the parser/lexer and creating the steps
 * for the pike VM to search. However, instruction tokens are ignored and handled in step 2. 2.
 * Assembly instructions and make the pattern context-aware. An instruction can generate different
 * encodings, each of which can change the context to a different value. New branches in the pattern
 * are created for each context.
 *
 * Each step is handled by its own visitor.
 */
public class PCVisitor extends pc_grammarBaseVisitor<Void> {

	private final Program currentProgram;
	private Address currentAddress;
	private final WildSleighAssembler assembler;
	private TaskMonitor monitor;
	private SleighLanguage language;

	private final List<OrMultiState> orStates;

	private final Deque<Integer> byteStack;
	private final Deque<PatternContext> contextStack;
	private final Deque<RegisterValue> ctxStack;
	private PatternContext currentContext; // contains output of first visitor
	private JSONObject metadata;
	private final MyErrorListener errorListener;

	private PatternContext outputContext; // contains output compiled pattern

	private ContextVisitor contextVisitor;
	private PathDeduplicator pathDeduplicator;

	/**
	 * Individual key-value pairs within a single "CONTEXT" block
	 */
	private final HashMap<String, RegisterValue> contextEntries;

	/**
	 * Local cache so we're not constantly querying to get this list
	 */
	private List<Register> validContextRegisters = null;

	// Needed to reimplement this class, luckily it's small
	static class ContextAdapter implements DisassemblerContextAdapter {
		private final RegisterValue contextIn;
		private final Map<Address, RegisterValue> contextsOut = new TreeMap<>();

		public ContextAdapter(RegisterValue contextIn) {
			this.contextIn = contextIn;
		}

		@Override
		public RegisterValue getRegisterValue(Register register) {
			if (register.getBaseRegister() == contextIn.getRegister()) {
				return contextIn.getRegisterValue(register);
			}
			return null;
		}

		@Override
		public void setFutureRegisterValue(Address address, RegisterValue value) {
			RegisterValue current = contextsOut.get(address);
			RegisterValue combined = current == null ? value : current.combineValues(value);
			contextsOut.put(address, combined);
		}

		public void addFlow(ProgramContext progCtx, Address after) {
			contextsOut.put(after, progCtx.getFlowValue(contextIn));
		}
	}

	/**
	 * This class contains the second step to creating the generated pattern. This step assembles
	 * all the assembly instruction steps, gathers the context for each instruction, and generates
	 * new branches and steps to make the pattern context aware.
	 */
	private class ContextVisitor {
		protected Stack<BranchHead> contextStack; // tracks new context branches that will be handled later
		protected Stack<Integer> contextOrStack; // tracks where the start of the split steps
		protected PatternContext contextAwareContext; // contains the generated pattern steps
		protected RegisterValue asmCurrentContext; // current context used for assembling instructions
		protected RegisterValue noFlowSave = null; // the context that should be reverted to in a noflow situation
		
		private ResultMap variantCtx;

		private record ContextChanges(RegisterValue localCtx, AddressMap globalCtx) {}

		private record ResultMap(HashMap<AssemblyParseResult, PatternMap> map) {
			ResultMap() {
				this(new HashMap<AssemblyParseResult, PatternMap>());
			}
		}

		private record PatternMap(HashMap<DefaultWildAssemblyResolvedPatterns, AddressMap> map) {
			PatternMap() {
				this(new HashMap<DefaultWildAssemblyResolvedPatterns, AddressMap>());
			}
		}

		private record AddressMap(HashMap<Address, RegisterValue> map) {
			AddressMap() {
				this(new HashMap<Address, RegisterValue>());
			}
		};
		
		private class BranchHead {
			LookupStep firstStep;
			RegisterValue context;
			RegisterValue noFlowContext;
			int startIdx;
		
			/**
			 * Represents the start of a branch in the generated pattern.
			 * @param firstStep an instruction that should be inserted as the first instruction in the branch; null if no instruction needs to be inserted, i.e. the first instruction of the branch is located at startIdx
			 * @param context context used to assemble the first instruction in the branch
			 * @param noFlowContext the context that should be reverted to if the start context is a noflow context; null if start context is not noflow
			 * @param startIdx index of the output of the first visitor where the first step of the branch begins
			 */
			private BranchHead(LookupStep firstStep, RegisterValue context, RegisterValue noFlowContext, int startIdx) {
				this.firstStep = firstStep;
				this.context = context;
				this.noFlowContext = noFlowContext;
				this.startIdx = startIdx;
			}
		}

		public ContextVisitor() {
			this.contextStack = new Stack<BranchHead>();
			this.contextOrStack = new Stack<Integer>();
			this.contextAwareContext = new PatternContext();
		}

		/**
		 * After the user pattern is passed through the first visitor above, run the output through this
		 * second visitor to make the generated pattern context-aware.
		 */
		public void makeContextAware() {
			// set first context
			RegisterValue initialContext = currentProgram.getProgramContext()
					.getDisassemblyContext(currentAddress);
			this.contextStack.add(new BranchHead(null, initialContext, null, 0));
			while (!this.contextStack.isEmpty()) {
				// process each context branch
				BranchHead branch = this.contextStack.removeLast();
				if (branch.firstStep != null) {
					this.contextAwareContext.steps().add(branch.firstStep);
				}
				asmCurrentContext = branch.context;
				for (int i = branch.startIdx; i < currentContext.steps.size(); i++) {
					// process each instruction within the context branch
					Step step = currentContext.steps.get(i);
					switch (step.getStepType()) {
						case SPLITMULTI:
							int nextInst = visit((SplitMulti) step);
							i = nextInst - 1;
							break;
						case JMP:
							nextInst = visit((Jmp) step);
							i = nextInst - 1;
							break;
						case LOOKUP:
							visit(i, ((LookupStep) step).copy());
							if (branch.noFlowContext != null) {
								// if we are at the beginning of a branch and there is a start context, set the context
								asmCurrentContext = handleNoFlows(branch.noFlowContext, asmCurrentContext);
								branch.noFlowContext = null;
								noFlowSave = null;
							}
							break;
						case CONTEXT:
							visit((Context) step);
							branch.noFlowContext = null; // user overrides all contexts
							break;
						default:
							visit(step);
							if (branch.noFlowContext != null) {
								// if we are at the beginning of a branch and there is a start context, set the context
								asmCurrentContext = handleNoFlows(branch.noFlowContext, asmCurrentContext);
								branch.noFlowContext = null;
								noFlowSave = null;
							}
					}

				}
				if (!this.contextStack.isEmpty()) {
					// there are more context branches to handle
					// add a jump, which will later be filled in with dest of end of pattern
					this.contextAwareContext.steps().add(new Jmp(0));
					// add the next destination for a Split or SplitMulti block
					int correspondingSplitIndex = this.contextOrStack.removeLast();
					SplitMulti sm =
						(SplitMulti) this.contextAwareContext.steps().get(correspondingSplitIndex);
					sm.addDest(this.contextAwareContext.steps().size());
				}
			}

			for (int i = 0; i < this.contextAwareContext.steps().size(); i++) {
				// turn all SplitMulti blocks with only 2 destinations into a Split block
				Step nextStep = this.contextAwareContext.steps().get(i);
				if (nextStep.getStepType() == Step.StepType.JMP) {
					// all jumps should go to the end of the pattern
					((Jmp) nextStep).setDest(this.contextAwareContext.steps().size());
				}
			}
		}

		// #region Visit methods
		/**
		 * Handles split step.
		 * @param splitMultiStep split step to process
		 * @return index of the step in the output of the first visitor from where the next branch
		 * should begin
		 */
		private int visit(SplitMulti splitMultiStep) {
			// when there is a split, we will process the first branch and put the other branches in a
			// stack to process them after the first branch
			for (int i = splitMultiStep.getDests().size() - 1; i > 0; i--) {
				this.contextOrStack.add(this.contextAwareContext.steps().size());
				this.contextStack
						.add(new BranchHead(null, asmCurrentContext, noFlowSave, splitMultiStep.getDests().get(i)));
			}
			this.contextAwareContext.steps()
					.add(new SplitMulti(this.contextAwareContext.steps().size() + 1));
			return splitMultiStep.getDests().get(0);
		}

		/**
		 * Handles jump step.
		 * @param jmpStep jump step to process
		 * @return step in output of the first visitor to jump to in order to continue processing the
		 * current branch
		 */
		private int visit(Jmp jmpStep) {
			return jmpStep.getDest();
		}

		/**
		 * Handles assembly instruction step.
		 * @param tokenIdx step number of this step in the output of the first visitor
		 * @param lookupStep the instruction to assemble
		 */
		private void visit(int tokenIdx, LookupStep lookupStep) {
			List<LookupStep> lookupSteps = assembleInstruction(lookupStep);
			if (lookupSteps == null) {
				return;
			}

			if (lookupSteps.size() > 1) {
				// Each lookup step contains all the valid encodings for a certain output context.
				// Because there is more than one output context, put a split in the results to
				// split over the different contexts
				this.contextAwareContext.steps().add(new SplitMulti(this.contextAwareContext.steps().size() + 1));
			}
			
			RegisterValue firstLookupStepContext = lookupSteps.getFirst().getOutputContext();
			// Determine if the next context is no flow
			boolean hasNoFlow = checkNoFlow(asmCurrentContext, firstLookupStepContext);

			if (hasNoFlow || noFlowSave == null) {
				// hasNoFlow is true & noFlowSave is null -> we are encountering a noflow, so save current context and set the noflow context as next context
				// hasNoFlow is true & noFlowSave is not null -> the previous and next contexts are noflows, original context already saved, so no need to do that
				// hasNoFlow is false & noFlowSave is null -> nothing related to noflow is happening; just set the next global context
				if (noFlowSave == null && hasNoFlow) {
					noFlowSave = asmCurrentContext;
				}
				asmCurrentContext = firstLookupStepContext;
				
			}
			else {
				// revert the noflow context to the original context
				asmCurrentContext = handleNoFlows(noFlowSave, firstLookupStepContext);
				noFlowSave = null;
			}
			
			// add first context branch to result
			this.contextAwareContext.steps().add(lookupSteps.getFirst());
			
			// if there are more branches, add them to a stack to process later
			for (int i = 1; i < lookupSteps.size(); i++) {
				this.contextOrStack.add(this.contextAwareContext.steps().size() - 2);
				this.contextStack
						.add(new BranchHead(lookupSteps.get(i), lookupSteps.get(i).getOutputContext(), noFlowSave, tokenIdx + 1));
			}
		}

		/**
		 * Handles step that allows user to override the current context.
		 * @param contextStep context step to process
		 */
		private void visit(Context contextStep) {
			for (RegisterValue contextVar : contextStep.getContextVars()) {
				// asmCurrentContext always contains the full context register
				// We set the specified value for the specified context variable in that context register
				contextVisitor.asmCurrentContext =
					contextVisitor.asmCurrentContext.assign(contextVar.getRegister(), contextVar);
			}
		}

		/**
		 * Handles all other steps not listed above.
		 * @param step step to process
		 */
		private void visit(Step step) {
			this.contextAwareContext.steps().add(step);
		}
		// #endregion
		
		/**
		 * Assembles an assembly instruction.
		 * @param lookupStep the lookup step containing the instruction to assemble
		 * @return a list of lookup steps filled in with encodings. Each LookupStep contains a
		 * different output context (new branch for each context)
		 */
		private List<LookupStep> assembleInstruction(LookupStep lookupStep) {
			Collection<AssemblyParseResult> parses = assembler
					.parseLine(lookupStep.getInstructionText())
					.stream()
					.filter(p -> {
						if (PickledCanary.DEBUG && p.isError()) {
							System.err.println("Error in AssemblyParseResult: " + p);
						}
						return !p.isError();
					})
					.toList();
			if (parses.isEmpty()) {
				raiseInvalidInstructionException(lookupStep);
			}

			List<LookupStep> lookupSteps = this.makeLookupStepFromParseResults(lookupStep, parses);
			if (lookupSteps == null) {
				return null;
			}
			if (lookupSteps.isEmpty()) {
				raiseInvalidInstructionException(lookupStep);
			}

			return lookupSteps;
		}

		/**
		 * Assembles an assembly instruction.
		 * @param lookupStep the lookup step containing the instruction to assemble
		 * @param parses the parsed data of the instruction to assemble
		 * @return a list of lookup steps filled in with encodings. Each LookupStep contains a
		 * different output context (new branch for each context)
		 */
		private List<LookupStep> makeLookupStepFromParseResults(LookupStep lookupStep,
				Collection<AssemblyParseResult> parses) {
			AssemblyPatternBlock assemblerCtx = AssemblyPatternBlock
					.fromRegisterValue(contextVisitor.asmCurrentContext);

			System.err.println("Context going into assembler: " + assemblerCtx);
			this.variantCtx = new ResultMap();
			
			// maps output context to a LookupStep containing encodings that produce the output context
			LinkedHashMap<RegisterValue, LookupStepBuilder> encodingResultsBuilders = new LinkedHashMap<>();
			for (AssemblyParseResult p : parses) {
				if (PickledCanary.DEBUG) {
					// Print each instruction variant
					System.err.println("parse = " + p);
				}

				AssemblyResolutionResults results;

				// Resolve each instruction variant to get the encodings
				// All variants should use the same input context (global context) for resolution
				// Encodings for variants which are not valid in the provided context are filtered out by the assembler
				results = assembler.resolveTree(p, currentAddress, assemblerCtx);

				if (monitor.isCancelled()) {
					// Yield if user wants to cancel operation
					return null;
				}

				PatternMap encodingCtx = new PatternMap();

				for (AssemblyResolution res : results) {
					if (res instanceof DefaultWildAssemblyResolvedPatterns pats) {
						// We must compute the context changes (if any) for every pats
						// The instruction encodings may affect the global context
						ContextChanges contextChanges =
							getContextChanges(pats, contextVisitor.asmCurrentContext);
						System.err.println("Printing local context: " + contextChanges.localCtx());

						AddressMap encodingContextChanges = contextChanges.globalCtx();

						encodingCtx.map.put(pats, encodingContextChanges);

						for (Address a : encodingContextChanges.map.keySet()) {
							// there are context changes to process
							// TODO: pickled canary currently assumes that all context changes
							// occur in the next instruction. This may not always be the case, as
							// an instruction can set a context for any address
							RegisterValue outputContext = encodingContextChanges.map.get(a);
							if (!encodingResultsBuilders.containsKey(outputContext)) {
								LookupStep lookupStepCopy = lookupStep.copy();
								lookupStepCopy.setOutputContext(outputContext);
								encodingResultsBuilders.put(outputContext, new LookupStepBuilder(
									lookupStepCopy, contextVisitor.contextAwareContext.tables));

							}
							encodingResultsBuilders.get(outputContext)
									.addAssemblyPattern(pats, contextChanges.localCtx());
						}
						if (encodingContextChanges.map.isEmpty()) {
							// no context changes means the current context will be the next context
							if (!encodingResultsBuilders.containsKey(asmCurrentContext)) {
								LookupStep lookupStepCopy = lookupStep.copy();
								lookupStepCopy.setOutputContext(asmCurrentContext);
								encodingResultsBuilders.put(asmCurrentContext,
									new LookupStepBuilder(lookupStepCopy,
										contextVisitor.contextAwareContext.tables));

							}
							encodingResultsBuilders.get(asmCurrentContext).addAssemblyPattern(pats, contextChanges.localCtx());
						}
					}
				}
				variantCtx.map.put(p, encodingCtx);
			}
			List<LookupStep> encodingResults = new ArrayList<>();
			for (LookupStepBuilder lsb : encodingResultsBuilders.values()) {
				encodingResults.add(lsb.buildLookupStep());
			}
			printContextChanges(this.variantCtx);
			return encodingResults;
		}
		
		/**
		 * Gets the changes to context produced by an encoding.
		 * @param pats an instruction encoding
		 * @param inputCtx the context used to aseemble to get the instruction encoding
		 * @return list of context changes produced by encoding
		 */
		public ContextChanges getContextChanges(DefaultAssemblyResolvedPatterns pats,
				RegisterValue inputCtx) {
			ContextAdapter contextAdapter = new ContextAdapter(inputCtx);
			ByteMemBufferImpl buffer = new ByteMemBufferImpl(currentAddress,
				pats.getInstruction().getVals(), language.isBigEndian());

			RegisterValue localCtx = null;
			// Use the language to parse the context changes for each encoding
			// We might be disassembling the instruction we just assembled
			try {
				SleighInstructionPrototype proto =
					(SleighInstructionPrototype) language.parse(buffer, contextAdapter, false);
				// Get the local context changes from the prototype
				// While we retrieve this for every encoding, we don't always need it
				localCtx = proto.getParserContext(buffer, contextAdapter).getContextRegisterValue();
			}
			catch (InsufficientBytesException | UnknownInstructionException
					| MemoryAccessException e) {
				e.printStackTrace();
			}

			// A single encoding may change the global context at multiple addresses
			AddressMap globalCtx = new AddressMap();

			for (Entry<Address, RegisterValue> ent : contextAdapter.contextsOut.entrySet()) {
				globalCtx.map.put(ent.getKey(), inputCtx.combineValues(ent.getValue()));
			}
			return new ContextChanges(localCtx, globalCtx);
		}

		private void printContextChanges(ResultMap variantCtx) {
			System.err.print(System.lineSeparator());

			for (AssemblyParseResult parseResult : variantCtx.map.keySet()) {
				System.err.println("Instruction variant: " + parseResult);

				PatternMap encodingCtx = variantCtx.map.get(parseResult);

				for (DefaultWildAssemblyResolvedPatterns resolvedPats : encodingCtx.map.keySet()) {
					System.err.println("Instruction encoding: " + resolvedPats.getInstruction());

					AddressMap addressCtx = encodingCtx.map.get(resolvedPats);

					for (Address address : addressCtx.map.keySet()) {
						System.err.println("Context: " + addressCtx.map.get(address) +
							" set at address: " + address);
					}
					System.err.print(System.lineSeparator());
				}
			}
		}

		/**
		 * Determines if a context is noflow.
		 * @param currCtx the context used to produce nextCtx
		 * @param nextCtx the context to check if it is noflow
		 * @return true if nextCtx is nowflow; false otherwise
		 */
		private boolean checkNoFlow(RegisterValue currCtx, RegisterValue nextCtx) {
			// TODO: Use cached contextreg and context variables
			Register contextReg = language.getContextBaseRegister();

			for (Register contextVar : contextReg.getChildRegisters()) {
				if (!contextVar.followsFlow() && !nextCtx.getRegisterValue(contextVar)
						.equals(currCtx.getRegisterValue(contextVar))) {
					return true;
				}
			}
			return false;
		}

		/**
		 * Undo the context in a noflow instruction. We aren't reverting the noflow variables in the next context.
		 * Instead, we update the saved context with only the variables that follow flow from the next context.
		 * @param saveCtx the context to revert to
		 * @param nextCtx the current context
		 * @return the context to revert to
		 */
		private RegisterValue handleNoFlows(RegisterValue saveCtx, RegisterValue nextCtx) {
			// TODO: Use cached contextreg and context variables
			Register contextReg = language.getContextBaseRegister();

			for (Register contextVar : contextReg.getChildRegisters()) {
				if (contextVar.followsFlow()) {
					saveCtx = saveCtx.assign(contextVar, nextCtx.getRegisterValue(contextVar));
				}
			}
			return saveCtx;
		}
	}

	/**
	 * After the pattern is passed through the second visitor to make the pattern context aware,
	 * the pattern may have several duplicate branches. This third step removes all duplicate
	 * branches.
	 */
	private class PathDeduplicator {

		private class InstructionNode {
			private Step step; // the instruction of the node
			private ArrayList<InstructionNode> children; // instructions that can be executed after current instruction
			
			// used for deduplication
			private int newStepsIdx; // the index of this node in the deduplicated list of steps
			private boolean doJump; // true if next step is duplicate
			
			/**
			 * Represents a node in the deduplication tree.
			 * @param step an instruction to execute
			 */
			private InstructionNode(Step step) {
				this.step = step;
				children = new ArrayList<>();
				doJump = false;
			}

			@Override
			public int hashCode() {
				final int prime = 31;
				int result = prime + Objects.hash(step, children);
				return result;
			}

			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				InstructionNode other = (InstructionNode) obj;
				return Objects.equals(step, other.step) &&
					Objects.equals(children, other.children);
			}
		}
		
		/**
		 * Remove duplicate branches in the pattern.
		 * 
		 * Steps to deduplicate:
		 * 1. Generate a tree out of all the steps in the pattern where each node is an instruction
		 * to execute. The children of each node are the next steps that can be executed.
		 * 2. When generating the tree, sometimes a next step can get added to the children more
		 * than once, so remove all duplicate next steps. We now have a directed acyclic graph.
		 * 3. The hash code of each node represents the content of the current step and all child
		 * steps down to the leaves. This makes up a branch. In the third step, duplicate branches
		 * are removed by traversing each node and ignoring branches that have already been seen.
		 * @param inputContext the input pattern
		 * @return deduplicated pattern
		 */
		public PatternContext deduplicatePaths(PatternContext inputContext) {
			// tree must have a root, so we add a filler step; otherwise, if pattern starts with OR
			// block, there will not be a root of the tree
			InstructionNode root = new InstructionNode(new LookupStep("ROOT", -1, -1));
			generateTree(0, root, inputContext.steps);
			removeDuplicateChildren(root);
			combineEncodingsWithEqualBranches(root);
			if (PickledCanary.DEBUG) {
				System.out.println("Deduplication tree:");
				printTree(0, root);
			}
			ArrayList<Step> newSteps = deduplicateTree(root);
			return new PatternContext(newSteps, inputContext.tables);
		}
		
		/**
		 * Generates the DAG from the list of steps to allow for deduplication. Splits and jumps
		 * are removed, and the step that is split or jumped to is placed in the children field.
		 * @param idx current step to process
		 * @param parent the previous step
		 * @param steps all the steps in the pattern
		 */
		private void generateTree(int idx, InstructionNode parent, List<Step> steps) {
			if (idx >= steps.size()) {
				// we've reached the end of a branch; no more steps to process on this branch
				return;
			}
			Step step = steps.get(idx);
			switch (step.getStepType()) {
				// for splits or jumps, just go to the next step(s)
				case SPLITMULTI:
					SplitMulti splitMulti = (SplitMulti) step;
					for (int dest : splitMulti.getDests()) {
						generateTree(dest, parent, steps);
					}
					break;
				case JMP:
					generateTree(((Jmp) step).getDest(), parent, steps);
					break;
				default:
					// for all other steps, add a node to the tree and go to the next step
					InstructionNode node = new InstructionNode(steps.get(idx));
					generateTree(idx + 1, node, steps);
					parent.children.add(node);
			}
		}
		
		/**
		 * Remove children under a node that are the same.
		 * @param node node to check for similar children
		 */
		private void removeDuplicateChildren(InstructionNode node) {
			LinkedHashSet<InstructionNode> set = new LinkedHashSet<>(node.children);
			node.children.clear();
			node.children.addAll(set);
			for (InstructionNode child : node.children) {
				removeDuplicateChildren(child);
			}
		}

		/**
		 * An instruction that produces encodings with different output contexts will cause a split
		 * in the pattern, and each of the encodings with a different output context will be placed
		 * as the first instruction after the split. Sometimes, the rest of the branches will be
		 * equal, and therefore, the rest of the branches can be deduplicated, and the encodings in
		 * the separate output context steps can be combined back together.
		 * 
		 * Two siblings with the same instruction text and the same children can be deduplicated.
		 * Therefore, deduplication is done by:
		 * 1) tracking siblings that meet the definition for deduplication
		 * 2) copying all encodings of all siblings into the first sibling
		 * 3) remove all siblings except the first from the parent's children list
		 * @param node node to combine instruction encodings with equal branches
		 */
		private void combineEncodingsWithEqualBranches(InstructionNode node) {
			// this hashmap tracks siblings with the same instruction text and children
			// instruction text          node's children      equal siblings indexes
			HashMap<String, HashMap<ArrayList<InstructionNode>, ArrayList<Integer>>> deduplicationTracker = new HashMap<>();
			for (int i = 0; i < node.children.size(); i++) {
				// this loop puts all siblings that meet the definition for deduplication in a group
				InstructionNode child = node.children.get(i);
				combineEncodingsWithEqualBranches(child);
				if (child.step.getStepType() != StepType.LOOKUP) {
					continue;
				}
				LookupStep step = (LookupStep) child.step;
				if (!deduplicationTracker.containsKey(step.getInstructionText())) {
					deduplicationTracker.put(step.getInstructionText(), new HashMap<>());
				}
				if (!deduplicationTracker.get(step.getInstructionText()).containsKey(child.children)) {
					deduplicationTracker.get(step.getInstructionText()).put(child.children, new ArrayList<>());
				}
				// group siblings by instruction text and siblings' children
				deduplicationTracker.get(step.getInstructionText()).get(child.children).add(i);
			}
			
			for (HashMap<ArrayList<InstructionNode>, ArrayList<Integer>> duplicateChildren : deduplicationTracker.values()) {
				for (ArrayList<Integer> combinableBranches : duplicateChildren.values()) {
					if (combinableBranches.size() < 2) {
						// if there's only 1 sibling in a group, no need to deduplicate
						continue;
					}
					
					// take the first sibling, add all encodings of the other siblings to first
					// sibling, then remove the other siblings
					Collections.sort(combinableBranches, Collections.reverseOrder());
					InstructionNode branchToKeep = node.children.get(combinableBranches.removeLast());
					LookupStep branchToKeepLookupStep = (LookupStep) branchToKeep.step;
					for (int idx : combinableBranches) {
						InstructionNode branchToCombine = node.children.get(idx);
						LookupStep branchToCombineLookupStep = (LookupStep) branchToCombine.step;
						branchToKeepLookupStep.combine(branchToCombineLookupStep);
						node.children.remove(idx);
					}
				}
			}
		}
		
		/**
		 * Prints out a tree.
		 * @param indent depth of indent to insert before printing a line
		 * @param node the tree to print
		 */
		private void printTree(int indent, InstructionNode node) {
			System.out.println("    ".repeat(indent) +  ": " + node.step.toString());
			for (InstructionNode child : node.children) {
				printTree(indent + 1, child);
			}
		}
		
		/**
		 * Remove branches that are the same by traversing through each node and ignoring branches
		 * that we have already seen.
		 * @param root the DAG to deduplicate
		 * @return a deduplicated list of steps
		 */
		private ArrayList<Step> deduplicateTree(InstructionNode root) {
			HashMap<InstructionNode, Integer> hashToIdx = new HashMap<>();
			ArrayList<Step> newSteps = new ArrayList<>();
			deduplicateTree(root, newSteps, hashToIdx); // the actual deduplication happens here
			newSteps.removeFirst(); // remove the filler step
			
			// if the last steps is a jump to the end, that is useless; remove it
			Step lastStep = newSteps.getLast();
			if (lastStep.getStepType() == Step.StepType.JMP && ((Jmp) lastStep).getDest() == -1) {
				newSteps.removeLast();
			}
			
			// resolve the destinations for splits and jumps
			for (int i = 0; i < newSteps.size(); i++) {
				Step step = newSteps.get(i);
				switch (step.getStepType()) {
					case JMP:
						Jmp jmp = (Jmp) step;
						if (jmp.getDest() == -1) {
							// -1 signifies jump to the end
							jmp.setDest(newSteps.size());
						} else {
							// otherwise, we need to subtract 1 from each jump to take into account
							// filler step
							jmp.setDest(jmp.getDest() - 1);
						}
						break;
					case SPLITMULTI:
						List<Integer> dests = ((SplitMulti) step).getDests();
						if (dests.size() == 2) {
							// if there are 2 destinations, SplitMulti can become Split
							// again, subtract 1 to take into account filler step
							newSteps.set(i, new Split(dests.get(0) - 1, dests.get(1) - 1));
						}
						else {
							SplitMulti splitMultiNew = new SplitMulti();
							for (int dest : dests) {
								// -1 to take into account filler step
								splitMultiNew.addDest(dest - 1);
							}
							newSteps.set(i, splitMultiNew);
						}
						break;
					default:
						// do nothing
				}
			}
			return newSteps;
		}
		
		/**
		 * The actual method that deduplicates branches.
		 * @param branch current branch to process
		 * @param newSteps list of steps where deduplicated output is written to
		 * @param hashToIdx map to keep track of the branches that we have already seen
		 */
		private void deduplicateTree(InstructionNode branch, ArrayList<Step> newSteps, HashMap<InstructionNode, Integer> hashToIdx) {
			if (hashToIdx.keySet().contains(branch)) {
				// we have already seen this branch, which means this branch is a duplicate; we
				// will point the next step to be the branch that we've already seen
				branch.newStepsIdx = hashToIdx.get(branch);
				branch.doJump = true;
				return;
			}
			
			// we have never seen this branch before; add to list of steps
			hashToIdx.put(branch, newSteps.size());
			branch.newStepsIdx = newSteps.size();
			newSteps.add(branch.step);
			
			switch (branch.children.size()) {
				case 0:
					// if there are no children, we are at the end of a branch, so jump to the end
					newSteps.add(new Jmp(-1));
					break;
				case 1:
					// there only one next step, so no need to have a split
					deduplicateTree(branch.children.getFirst(), newSteps, hashToIdx);
					if (branch.children.getFirst().doJump) {
						// if child branch is duplicated, just jump to the branch already seen
						newSteps.add(new Jmp(hashToIdx.get(branch.children.getFirst())));
					}
					break;
				default:
					// 2 or more children, so split is required
					SplitMulti splitMulti = new SplitMulti();
					newSteps.add(splitMulti);
					for (InstructionNode child : branch.children) {
						deduplicateTree(child, newSteps, hashToIdx);
						// add the appropriate location to jump to
						splitMulti.addDest(child.newStepsIdx);
					}
			}
		}
	}

	/**
	 * Construct visitor to build Step output.
	 *
	 * You likely want to call {@link #lexParseAndVisit(String, TaskMonitor)} once you've created an
	 * instance of this class. After that, {@link #getJSONObject(boolean)} or {@link #getPattern()}
	 * can be used to get the pattern output for export or searching respectively
	 *
	 * This visitor can be reused for multiple patterns IF the reset method is called between calls
	 * to {@link #lexParseAndVisit(String, TaskMonitor)}.
	 *
	 * @param currentProgram
	 * @param currentAddress
	 * @param monitor
	 */
	public PCVisitor(final Program currentProgram, final Address currentAddress,
			final TaskMonitor monitor) {
		this.currentProgram = currentProgram;
		this.currentAddress = currentAddress;
		this.monitor = monitor;
		this.language = (SleighLanguage) currentProgram.getLanguage();
		WildSleighAssemblerBuilder builder = new WildSleighAssemblerBuilder(language);
		this.assembler = builder.getAssembler(new AssemblySelector(), currentProgram);

		this.orStates = new ArrayList<>();
		this.byteStack = new ArrayDeque<>();

		this.currentContext = new PatternContext();
		this.contextStack = new ArrayDeque<>();
		this.ctxStack = new ArrayDeque<>();

		this.metadata = new JSONObject();
		errorListener = new MyErrorListener();

		this.contextVisitor = new ContextVisitor();
		this.pathDeduplicator = new PathDeduplicator();

		this.contextEntries = new HashMap<>();
	}

	/**
	 * Reset back to state where this visitor can visit a new pattern.
	 */
	public void reset() {
		this.orStates.clear();
		this.byteStack.clear();
		this.currentContext = new PatternContext();
		this.contextStack.clear();
		this.ctxStack.clear();
		this.metadata = new JSONObject();

		//		this.futureContexts.clear();

		this.contextVisitor = new ContextVisitor();
		this.contextEntries.clear();
	}

	private static void raiseInvalidInstructionException(LookupStep lookupStep) {
		String instructionText = lookupStep.getInstructionText();

		if (instructionText.chars().filter(ch -> ch == '`').count() % 2 != 0) {
			throw new QueryParseException(
				"This line doesn't have a balanced number of '`' characters and didn't assemble to any instruction",
				lookupStep);
		}
		throw new QueryParseException(
			"An assembly instruction in your pattern (" + instructionText +
				") did not return any output. Make sure your assembly instructions" +
				" are valid or that you are using a binary with the same architecture.",
			lookupStep);
	}

	// region Visit methods
	@Override
	public Void visitAny_bytes(pc_grammar.Any_bytesContext ctx) {

		Integer min = Integer.decode(ctx.getChild(1).getText());
		Integer max = Integer.decode(ctx.getChild(3).getText());
		Integer step = 1;

		if (ctx.children.size() > 6) {
			step = Integer.decode(ctx.getChild(5).getText());
		}

		var note = String.format(
			"AnyBytesNode Start: %d End: %d Interval: %d From: Token from line #%d: Token type: PICKLED_CANARY_COMMAND data: `%s`",
			min, max, step, ctx.start.getLine(), ctx.getText());

		this.currentContext.steps().add(new AnyByteSequence(min, max, step, note));

		return null;
	}

	@Override
	public Void visitByte_match(pc_grammar.Byte_matchContext ctx) {
		visitChildren(ctx);
		this.currentContext.steps().add(new Byte(this.byteStack.pop()));
		return null;
	}

	@Override
	public Void visitByte_string(pc_grammar.Byte_stringContext ctx) {

		var stringData = ctx.getText().strip();
		// Remove starting and ending '"' and translate escapes
		stringData = stringData.substring(1, stringData.length() - 1).translateEscapes();

		// Add a "Byte" for each character
		for (int x : stringData.toCharArray()) {
			this.currentContext.steps().add(new Byte(x));
		}

		return null;
	}

	@Override
	public Void visitMasked_byte(pc_grammar.Masked_byteContext ctx) {
		visitChildren(ctx);
		var value = this.byteStack.pop();
		var mask = this.byteStack.pop();
		this.currentContext.steps().add(new MaskedByte(mask, value));
		return null;
	}

	@Override
	public Void visitByte(pc_grammar.ByteContext ctx) {
		this.byteStack.push(Integer.decode(ctx.getText()));
		return null;
	}

	@Override
	public Void visitLabel(pc_grammar.LabelContext ctx) {
		var label = ctx.getText().strip();
		label = label.substring(0, label.length() - 1);
		this.currentContext.steps().add(new Label(label));
		return null;
	}

	@Override
	public Void visitMeta(pc_grammar.MetaContext ctx) {
		String meta = ctx.getText();
		// Remove `META` at the start
		meta = meta.replaceFirst("^ *`META`[\r\n]+", "");
		// Remove "`META_END`" at the end
		meta = meta.substring(0, meta.length() - 10);
		// Remove any comments
		meta = meta.replaceAll("[\n\r]+ *;[^\n\r]*", "");

		// Check if our existing metadata is equal to an empty JSONObject
		if (this.metadata.toString().equals(new JSONObject().toString())) {
			this.metadata = new JSONObject(meta);
		}
		else {
			throw new QueryParseException("Can not have more than one META section!", ctx);
		}
		return null;
	}

	@Override
	public Void visitStart_or(pc_grammar.Start_orContext ctx) {
		// Add a new "split" step for this OR block.
		this.currentContext.steps().add(new SplitMulti(this.currentContext.steps().size() + 1));

		// Add a new OrState and reference the index of the split node for this Or block
		this.orStates.add(new OrMultiState(this.currentContext.steps().size() - 1));
		return null;
	}

	@Override
	public Void visitMiddle_or(pc_grammar.Middle_orContext ctx) {
		// Add a new "jmp" step to (eventually) go to after the second "or" option.
		this.currentContext.steps().add(new Jmp(this.currentContext.steps().size() + 1));

		OrMultiState currentOrState = this.orStates.get(this.orStates.size() - 1);
		currentOrState.addMiddleStep(this.currentContext.steps().size() - 1);

		// Update the split to have its next dest point to here after the jmp ending
		// the first option
		SplitMulti s = (SplitMulti) this.currentContext.steps().get(currentOrState.getStartStep());
		s.addDest(this.currentContext.steps().size());
		return null;
	}

	@Override
	public Void visitEnd_or(pc_grammar.End_orContext ctx) {
		// Pop the current orState off the end (we're done with it)
		OrMultiState currentOrState = this.orStates.remove(this.orStates.size() - 1);

		// Update the jmp after each "or" option to jump to here (after the final
		// "or")
		List<Integer> middleSteps = currentOrState.getMiddleSteps();
		for (Integer jmp_idx : middleSteps) {
			Jmp j = (Jmp) this.currentContext.steps().get(jmp_idx);
			j.setDest(this.currentContext.steps().size());
		}
		return null;
	}

	@Override
	public Void visitStart_negative_lookahead(pc_grammar.Start_negative_lookaheadContext ctx) {
		// When we get into a "not" block, we'll essentially start to create a new
		// pattern (for the contents of the "not" block). We do this here by saving off
		// our current "steps" and "tables" and creating new ones that our next nodes
		// (until the end of the not block) will populate. When we get to the end of the
		// "not" block, we'll package up the then-current steps and tables into a
		// pattern (the new ones we're creating here), restore the steps and tables
		// saved here, and add the "NegativeLookahead" step containing the
		// just-generated pattern.
		this.contextStack.push(this.currentContext);
		this.currentContext = new PatternContext();
		return null;
	}

	@Override
	public Void visitEnd_negative_lookahead(pc_grammar.End_negative_lookaheadContext ctx) {
		// The final step of the not block should be a Match, so add it here.
		this.currentContext.steps.add(new Match());

		// Generate the JSON for the inner-pattern (that will go within the
		// NegativeLookahead)
		this.currentContext.canonicalize();
		JSONObject notPattern = this.currentContext.getJson(this.metadata);

		// Restore our "outer"/"main" steps and tables (which were saved at the
		// NotStartNode)
		this.currentContext = this.contextStack.pop();

		// Add the NegativeLookahead step (including its inner-pattern) to our main set
		// of steps
		this.currentContext.steps().add(new NegativeLookahead(notPattern));
		return null;
	}

	@Override
	public Void visitInstruction(pc_grammar.InstructionContext ctx) {
		if (PickledCanary.DEBUG) {
			System.out.println("CURRENTLY PROCESSING: " + ctx.getText());
		}

		LookupStep lookupStep = new LookupStep(ctx.getText(), ctx.start.getLine(),
			ctx.start.getCharPositionInLine());

		this.currentContext.steps().add(lookupStep);

		return null;
	}

	@Override
	public Void visitContext_entry(pc_grammar.Context_entryContext ctx) {

		String[] parts = ctx.getText().split("=");
		String name = parts[0].strip();
		String valueString = parts[1].strip();
		RegisterValue contextVar;

		// Check name is valid
		if (this.contextEntries.containsKey(name)) {
			throw new QueryParseException(
				"Cannot specify context value more than once! '" + name + "' was duplicated.", ctx);
		}

		if (this.validContextRegisters == null) {
			this.validContextRegisters = currentProgram.getProgramContext().getContextRegisters();
		}
		Optional<Register> match = this.validContextRegisters.stream()
				.filter(reg -> reg.getName().equals(name))
				.findFirst();

		if (match.isEmpty()) {
			throw new QueryParseException("Invalid context variable '" + name + "' for language!",
				ctx);

		}

		// Parse value for name

		BigInteger value = null;

		// If we have a quoted string, we're dealing with the
		// NumericUtilities#convertHexStringToMaskedValue(AtomicLong, AtomicLong, String, int, int,
		// String) format
		if (valueString.startsWith("\"") || valueString.startsWith("'")) {
			if (!valueString.endsWith(valueString.substring(0, 1))) {
				throw new QueryParseException("Expected quoted string to end with a matching quote",
					ctx);
			}

			// Remove first and last characters (the quote characters we just found above)
			String valueStringInner = valueString.substring(1, valueString.length() - 1);

			// Parse the given string to an AssemblyPatternBlock and then convert that a
			// RegisterValue
			// TODO: Do we need to be more sophisticated in our conversion here, especially when the
			// input string might start with 1 and be seen as negative in the BigIntegers
			AssemblyPatternBlock a = AssemblyPatternBlock.fromString(valueStringInner);
			value = new BigInteger(a.getValsAll());
			BigInteger mask = new BigInteger(a.getMaskAll());
			contextVar = new RegisterValue(match.get(), value, mask);
		}
		else {
			// Else try simpler radix based formats (with no unknown bits)
			try {
				if (valueString.length() > 2) {
					String valuePrefix = valueString.substring(0, 2);
					if (valuePrefix.equals("0x")) {
						value = new BigInteger(valueString.substring(2), 16);
					}
					else if (valuePrefix.equals("0b")) {
						value = new BigInteger(valueString.substring(2), 2);
					}
				}
				if (value == null) {
					value = new BigInteger(valueString);
				}
			}
			catch (NumberFormatException e) {
				throw new QueryParseException(
					"Unable to parse context value: '" + valueString +
						" '. Is it properly prefixed with '0x' for hex, '0b' for binary, or no prefix for base 10?",
					ctx);
			}

			contextVar = new RegisterValue(match.get(), value);
		}

		System.err.println("Going to set this context variable: " + contextVar);
		this.contextEntries.put(name, contextVar);

		return null;
	}

	@Override
	public Void visitContext(pc_grammar.ContextContext ctx) {
		visitChildren(ctx);
		// Transient context override step
		Context contextStep = new Context();

		for (RegisterValue contextVar : contextEntries.values()) {
			contextStep.addContextVar(contextVar);
		}

		// Reset entries so we're ready for the next context block
		contextEntries.clear();

		this.currentContext.steps().add(contextStep);

		return null;
	}
	// end region

	/**
	 * Return the results of having processed the pattern as a {@link JSONObject} which can be used
	 * to output this compiled pattern.
	 *
	 * @param withDebugInfo Include an extra "compile_info" tag with debug information (or not)
	 * @return A {@link JSONObject} containing the processed equivalent of the last pattern visited.
	 */
	public JSONObject getJSONObject(boolean withDebugInfo) {
		this.outputContext.canonicalize();
		JSONObject output = this.outputContext.getJson(this.metadata);

		if (withDebugInfo) {
			output.append("compile_info", this.getDebugJson());
		}
		else {
			output.put("compile_info", new JSONArray());
		}

		return output;
	}

	/**
	 * Return the results of having processed the pattern as a {@link Pattern} which can be used to
	 * perform a search.
	 *
	 * @return A {@link Pattern} object containing the processed equivalent of the last pattern
	 *         visited.
	 */
	public Pattern getPattern() {
		this.outputContext.canonicalize();
		return this.outputContext.getPattern();
	}

	private JSONObject getDebugJson() {
		JSONObject compileInfo = new JSONObject();
		JSONObject sourceBinaryInfo = new JSONObject();
		sourceBinaryInfo.append("path", this.currentProgram.getExecutablePath());
		sourceBinaryInfo.append("md5", this.currentProgram.getExecutableMD5());
		sourceBinaryInfo.append("compiled_at_address", this.currentAddress);
		compileInfo.append("compiled_using_binary", sourceBinaryInfo);
		compileInfo.append("language_id", this.currentProgram.getLanguageID().getIdAsString());
		return compileInfo;
	}

	private record PatternContext(List<Step> steps, AllLookupTables tables) {
		PatternContext() {
			this(new ArrayList<>(), new AllLookupTables());
		}

		/**
		 * Replace temporary refs in the data structure with canonical id's.
		 */
		void canonicalize() {
			for (Step step : this.steps) {
				if (step instanceof LookupStep lookupStep) {
					lookupStep.resolveTableIds(this.tables);
				}
			}
		}

		Pattern getPattern() {
			return new Pattern(this.steps, this.tables.getPatternTables());
		}

		/**
		 * Get raw JSON (without) any debug or compile info
		 *
		 * @return the JSON for this context
		 */
		JSONObject getJson(JSONObject metadata) {
			JSONObject out = new JSONObject();

			JSONArray arr = new JSONArray();
			for (Step step : steps) {
				arr.put(step.getJson());
			}
			out.put("steps", arr);
			out.put("tables", tables.getJson());
			out.put("pattern_metadata", metadata);
			return out;
		}
	}

	/**
	 * Update the address used by this visitor to assemble given instructions.
	 *
	 * @param address The address that we want to compile at
	 */
	public void setCurrentAddress(Address address) {
		currentAddress = address;
	}

	public void setMonitor(TaskMonitor m) {
		monitor = m;
	}

	private static class MyErrorListener extends BaseErrorListener {
		@Override
		public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line,
				int charPositionInLine, String msg, RecognitionException e) {
			throw new QueryParseException(msg, line, charPositionInLine);
		}
	}

	/**
	 * Process the given pattern, making results available in {@link #getPattern()} or
	 * {@link #getJSONObject(boolean)} methods.
	 *
	 * Call {@link #reset()} in between calls to this method if reusing this instance. If
	 * currentAddress has changed since this instance was created, call
	 * {@link #setCurrentAddress(Address)} before calling this method
	 *
	 * @param pattern    The pattern string to parse into steps
	 * @param newMonitor A monitor to display progress
	 */
	public void lexParseAndVisit(String pattern, TaskMonitor newMonitor) {
		monitor = newMonitor;
		monitor.setIndeterminate(true);

		var chars = CharStreams.fromString(pattern);
		var lexer = new pc_lexer(chars);
		lexer.addErrorListener(errorListener);
		var commonTokenStream = new CommonTokenStream(lexer);
		var parser = new pc_grammar(commonTokenStream);
		parser.addErrorListener(errorListener);

		var progContext = parser.prog();

		this.visit(progContext);
		this.contextVisitor.makeContextAware();
		outputContext = this.pathDeduplicator.deduplicatePaths(contextVisitor.contextAwareContext);
		
		if (PickledCanary.DEBUG) {
			System.out.println("initial pattern");
			for (int i = 0; i < currentContext.steps.size(); i++) {
				System.out.println(i + ": " + currentContext.steps.get(i));
			}
			System.out.println("context pattern");
			for (int i = 0; i < contextVisitor.contextAwareContext.steps.size(); i++) {
				System.out.println(i + ": " + contextVisitor.contextAwareContext.steps.get(i));
			}
			System.out.println("final pattern");
			for (int i = 0; i < outputContext.steps.size(); i++) {
				System.out.println(i + ": " + outputContext.steps.get(i));
			}
		}

		monitor.setIndeterminate(false);
	}

}
